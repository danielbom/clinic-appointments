// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: services_available_queries.sql

package infra

import (
	"context"

	"github.com/google/uuid"
)

const getServiceAvailableByID = `-- name: GetServiceAvailableByID :one

SELECT "sn"."id" as "service_name_id", "sn"."name" as "service_name",
    "sp"."id" as "specialization_id", "sp"."name" as "specialization"
FROM "service_names" "sn"
JOIN "specializations" "sp" ON "sn"."specialization_id" = "sp"."id"
WHERE "sn"."id" = $1
`

type GetServiceAvailableByIDRow struct {
	ServiceNameID    uuid.UUID
	ServiceName      string
	SpecializationID uuid.UUID
	Specialization   string
}

// SELECT "sn"."id", "sn"."name",
//
//	"sn"."specialization_id", "sz"."name" as "specialization_name"
//
// FROM "service_names" "sn"
// JOIN "specializations" "sz" ON "sn"."specialization_id" = "sz"."id"
// WHERE true
//
//	AND ($1::text = '' OR LOWER(unaccent("sz"."name")) LIKE '%' || LOWER(unaccent($1)) || '%')
//	AND ($2::text = '' OR LOWER(unaccent("sn"."name")) LIKE '%' || LOWER(unaccent($2)) || '%');
func (q *Queries) GetServiceAvailableByID(ctx context.Context, id uuid.UUID) (GetServiceAvailableByIDRow, error) {
	row := q.db.QueryRow(ctx, getServiceAvailableByID, id)
	var i GetServiceAvailableByIDRow
	err := row.Scan(
		&i.ServiceNameID,
		&i.ServiceName,
		&i.SpecializationID,
		&i.Specialization,
	)
	return i, err
}
