// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: appointments_queries.sql

package infra

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const appointmentsIntersects = `-- name: AppointmentsIntersects :one
SELECT COUNT("date") > 0
FROM "appointments"
WHERE "date" = $1 
  AND "specialist_id" = $2
  AND (
    ("time" <= $3::time AND $3::time < "time" + "duration") OR
    ("time" < $3::time + $4::interval AND $3::time + $4::interval < "time" + "duration")
  )
LIMIT 1
`

type AppointmentsIntersectsParams struct {
	Date         pgtype.Date
	SpecialistID uuid.UUID
	Time         pgtype.Time
	Duration     pgtype.Interval
}

func (q *Queries) AppointmentsIntersects(ctx context.Context, arg AppointmentsIntersectsParams) (bool, error) {
	row := q.db.QueryRow(ctx, appointmentsIntersects,
		arg.Date,
		arg.SpecialistID,
		arg.Time,
		arg.Duration,
	)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const countAppointments = `-- name: CountAppointments :one
SELECT COUNT("a"."id")
FROM "appointments" "a"
JOIN "customers" "c" ON "a"."customer_id" = "c"."id"
JOIN "specialists" "s" ON "a"."specialist_id" = "s"."id"
JOIN "service_names" "sn" ON "a"."service_name_id" = "sn"."id"
WHERE true
  AND ($1::date IS NULL OR "a"."date" >= $1) 
  AND ($2::date IS NULL OR "a"."date" <= $2)
  AND ($3::text = '' OR "c"."name" ILIKE '%' || $3 || '%')
  AND ($4::text = '' OR "s"."name" ILIKE '%' || $3 || '%')
  AND ($5::text = '' OR "sn"."name" ILIKE '%' || $3 || '%')
  AND ($6::int = 0 OR "a"."status" = $6)
`

type CountAppointmentsParams struct {
	Column1 pgtype.Date
	Column2 pgtype.Date
	Column3 string
	Column4 string
	Column5 string
	Column6 int32
}

func (q *Queries) CountAppointments(ctx context.Context, arg CountAppointmentsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAppointments,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAppointment = `-- name: CreateAppointment :one
INSERT INTO "appointments" ("customer_id", "specialist_id", "service_name_id", "price", "duration", "date", "time", "status")
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING "id"
`

type CreateAppointmentParams struct {
	CustomerID    uuid.UUID
	SpecialistID  uuid.UUID
	ServiceNameID uuid.UUID
	Price         int32
	Duration      pgtype.Interval
	Date          pgtype.Date
	Time          pgtype.Time
	Status        int32
}

func (q *Queries) CreateAppointment(ctx context.Context, arg CreateAppointmentParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createAppointment,
		arg.CustomerID,
		arg.SpecialistID,
		arg.ServiceNameID,
		arg.Price,
		arg.Duration,
		arg.Date,
		arg.Time,
		arg.Status,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const deleteAppointment = `-- name: DeleteAppointment :execrows
DELETE FROM "appointments"
WHERE "id" = $1
`

func (q *Queries) DeleteAppointment(ctx context.Context, id uuid.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteAppointment, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getAppointmentByID = `-- name: GetAppointmentByID :one
SELECT "id", "customer_id", "specialist_id", "service_name_id", "price", "duration", "date", "time", "status", "notified_at", "notified_by"
FROM "appointments"
WHERE "id" = $1
`

func (q *Queries) GetAppointmentByID(ctx context.Context, id uuid.UUID) (Appointment, error) {
	row := q.db.QueryRow(ctx, getAppointmentByID, id)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.SpecialistID,
		&i.ServiceNameID,
		&i.Price,
		&i.Duration,
		&i.Date,
		&i.Time,
		&i.Status,
		&i.NotifiedAt,
		&i.NotifiedBy,
	)
	return i, err
}

const getAppointmentEnrichedByID = `-- name: GetAppointmentEnrichedByID :one
SELECT "a"."id", "a"."price", "a"."duration", "a"."date", "a"."time", "a"."status", "a"."notified_at", "a"."notified_by",
  "a"."customer_id", "c"."name" as "customer_name",
  "a"."specialist_id", "s"."name" as "specialist_name",
  "a"."service_name_id", "sn"."name" as "service_name"
FROM "appointments" "a"
JOIN "customers" "c" ON "a"."customer_id" = "c"."id"
JOIN "specialists" "s" ON "a"."specialist_id" = "s"."id"
JOIN "service_names" "sn" ON "a"."service_name_id" = "sn"."id"
WHERE "a"."id" = $1
`

type GetAppointmentEnrichedByIDRow struct {
	ID             uuid.UUID
	Price          int32
	Duration       pgtype.Interval
	Date           pgtype.Date
	Time           pgtype.Time
	Status         int32
	NotifiedAt     pgtype.Timestamptz
	NotifiedBy     uuid.UUID
	CustomerID     uuid.UUID
	CustomerName   string
	SpecialistID   uuid.UUID
	SpecialistName string
	ServiceNameID  uuid.UUID
	ServiceName    string
}

func (q *Queries) GetAppointmentEnrichedByID(ctx context.Context, id uuid.UUID) (GetAppointmentEnrichedByIDRow, error) {
	row := q.db.QueryRow(ctx, getAppointmentEnrichedByID, id)
	var i GetAppointmentEnrichedByIDRow
	err := row.Scan(
		&i.ID,
		&i.Price,
		&i.Duration,
		&i.Date,
		&i.Time,
		&i.Status,
		&i.NotifiedAt,
		&i.NotifiedBy,
		&i.CustomerID,
		&i.CustomerName,
		&i.SpecialistID,
		&i.SpecialistName,
		&i.ServiceNameID,
		&i.ServiceName,
	)
	return i, err
}

const listAppointments = `-- name: ListAppointments :many
SELECT "a"."id", "a"."price", "a"."duration", "a"."date", "a"."time", "a"."status", "a"."notified_at", "a"."notified_by",
  "a"."customer_id", "c"."name" as "customer_name",
  "a"."specialist_id", "s"."name" as "specialist_name",
  "a"."service_name_id", "sn"."name" as "service_name"
FROM "appointments" "a"
JOIN "customers" "c" ON "a"."customer_id" = "c"."id"
JOIN "specialists" "s" ON "a"."specialist_id" = "s"."id"
JOIN "service_names" "sn" ON "a"."service_name_id" = "sn"."id"
WHERE true
  AND ($1::date IS NULL OR "a"."date" >= $1) 
  AND ($2::date IS NULL OR "a"."date" <= $2)
  AND ($3::text = '' OR "c"."name" ILIKE '%' || $3 || '%')
  AND ($4::text = '' OR "s"."name" ILIKE '%' || $4 || '%')
  AND ($5::text = '' OR "sn"."name" ILIKE '%' || $5 || '%')
  AND ($6::int = 0 OR "a"."status" = $6)
ORDER BY "a"."date" DESC, "a"."time" DESC
LIMIT $7
OFFSET $8
`

type ListAppointmentsParams struct {
	Column1 pgtype.Date
	Column2 pgtype.Date
	Column3 string
	Column4 string
	Column5 string
	Column6 int32
	Limit   int32
	Offset  int32
}

type ListAppointmentsRow struct {
	ID             uuid.UUID
	Price          int32
	Duration       pgtype.Interval
	Date           pgtype.Date
	Time           pgtype.Time
	Status         int32
	NotifiedAt     pgtype.Timestamptz
	NotifiedBy     uuid.UUID
	CustomerID     uuid.UUID
	CustomerName   string
	SpecialistID   uuid.UUID
	SpecialistName string
	ServiceNameID  uuid.UUID
	ServiceName    string
}

func (q *Queries) ListAppointments(ctx context.Context, arg ListAppointmentsParams) ([]ListAppointmentsRow, error) {
	rows, err := q.db.Query(ctx, listAppointments,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAppointmentsRow
	for rows.Next() {
		var i ListAppointmentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Price,
			&i.Duration,
			&i.Date,
			&i.Time,
			&i.Status,
			&i.NotifiedAt,
			&i.NotifiedBy,
			&i.CustomerID,
			&i.CustomerName,
			&i.SpecialistID,
			&i.SpecialistName,
			&i.ServiceNameID,
			&i.ServiceName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAppointmentsByDate = `-- name: ListAppointmentsByDate :many
SELECT "id", "customer_id", "specialist_id", "service_name_id", "price", "duration", "date", "time", "status", "notified_at", "notified_by"
FROM "appointments"
WHERE "date" = $1
ORDER BY "date" DESC, "time" DESC
`

func (q *Queries) ListAppointmentsByDate(ctx context.Context, date pgtype.Date) ([]Appointment, error) {
	rows, err := q.db.Query(ctx, listAppointmentsByDate, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Appointment
	for rows.Next() {
		var i Appointment
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.SpecialistID,
			&i.ServiceNameID,
			&i.Price,
			&i.Duration,
			&i.Date,
			&i.Time,
			&i.Status,
			&i.NotifiedAt,
			&i.NotifiedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAppointmentsBySpecialistID = `-- name: ListAppointmentsBySpecialistID :many
SELECT "a"."id", "a"."price", "a"."duration", "a"."date", "a"."time", "a"."status", "a"."notified_at", "a"."notified_by",
  "a"."customer_id", "c"."name" as "customer_name",
  "a"."service_name_id", "sn"."name" as "service_name"
FROM "appointments" "a"
JOIN "customers" "c" ON "a"."customer_id" = "c"."id"
JOIN "service_names" "sn" ON "a"."service_name_id" = "sn"."id"
WHERE "a"."specialist_id" = $1 
  AND ($2::text = '' OR "a"."date" = DATE($2))
ORDER BY "a"."date" DESC, "a"."time" DESC
`

type ListAppointmentsBySpecialistIDParams struct {
	SpecialistID uuid.UUID
	Column2      string
}

type ListAppointmentsBySpecialistIDRow struct {
	ID            uuid.UUID
	Price         int32
	Duration      pgtype.Interval
	Date          pgtype.Date
	Time          pgtype.Time
	Status        int32
	NotifiedAt    pgtype.Timestamptz
	NotifiedBy    uuid.UUID
	CustomerID    uuid.UUID
	CustomerName  string
	ServiceNameID uuid.UUID
	ServiceName   string
}

func (q *Queries) ListAppointmentsBySpecialistID(ctx context.Context, arg ListAppointmentsBySpecialistIDParams) ([]ListAppointmentsBySpecialistIDRow, error) {
	rows, err := q.db.Query(ctx, listAppointmentsBySpecialistID, arg.SpecialistID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAppointmentsBySpecialistIDRow
	for rows.Next() {
		var i ListAppointmentsBySpecialistIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Price,
			&i.Duration,
			&i.Date,
			&i.Time,
			&i.Status,
			&i.NotifiedAt,
			&i.NotifiedBy,
			&i.CustomerID,
			&i.CustomerName,
			&i.ServiceNameID,
			&i.ServiceName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAppointmentsCalendar = `-- name: ListAppointmentsCalendar :many
SELECT "a"."id", "a"."date", "a"."time", "a"."status", "s"."name" as "specialist_name"
FROM "appointments" "a"
JOIN "specialists" "s" ON "a"."specialist_id" = "s"."id"
WHERE true
  AND "a"."date" >= $1
  AND "a"."date" <= $2
ORDER BY "a"."date" DESC, "a"."time" DESC
`

type ListAppointmentsCalendarParams struct {
	Date   pgtype.Date
	Date_2 pgtype.Date
}

type ListAppointmentsCalendarRow struct {
	ID             uuid.UUID
	Date           pgtype.Date
	Time           pgtype.Time
	Status         int32
	SpecialistName string
}

func (q *Queries) ListAppointmentsCalendar(ctx context.Context, arg ListAppointmentsCalendarParams) ([]ListAppointmentsCalendarRow, error) {
	rows, err := q.db.Query(ctx, listAppointmentsCalendar, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAppointmentsCalendarRow
	for rows.Next() {
		var i ListAppointmentsCalendarRow
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Time,
			&i.Status,
			&i.SpecialistName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAppointmentsCalendarCount = `-- name: ListAppointmentsCalendarCount :many
SELECT date_part('month', "a"."date")::int as "month", "status", COUNT("a"."id")::int as "count"
FROM "appointments" "a"
WHERE "date" >= $1
  AND "date" <= $2
GROUP BY "month", "status"
ORDER BY "month" ASC
`

type ListAppointmentsCalendarCountParams struct {
	Date   pgtype.Date
	Date_2 pgtype.Date
}

type ListAppointmentsCalendarCountRow struct {
	Month  int32
	Status int32
	Count  int32
}

func (q *Queries) ListAppointmentsCalendarCount(ctx context.Context, arg ListAppointmentsCalendarCountParams) ([]ListAppointmentsCalendarCountRow, error) {
	rows, err := q.db.Query(ctx, listAppointmentsCalendarCount, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAppointmentsCalendarCountRow
	for rows.Next() {
		var i ListAppointmentsCalendarCountRow
		if err := rows.Scan(&i.Month, &i.Status, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAppointment = `-- name: UpdateAppointment :one
UPDATE "appointments"
SET
  "date" = $1,
  "time" = $2,
  "status" = $3
WHERE "id" = $4
RETURNING "id", "customer_id", "specialist_id", "service_name_id", "price", "duration", "date", "time", "status", "notified_at", "notified_by"
`

type UpdateAppointmentParams struct {
	Date   pgtype.Date
	Time   pgtype.Time
	Status int32
	ID     uuid.UUID
}

func (q *Queries) UpdateAppointment(ctx context.Context, arg UpdateAppointmentParams) (Appointment, error) {
	row := q.db.QueryRow(ctx, updateAppointment,
		arg.Date,
		arg.Time,
		arg.Status,
		arg.ID,
	)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.SpecialistID,
		&i.ServiceNameID,
		&i.Price,
		&i.Duration,
		&i.Date,
		&i.Time,
		&i.Status,
		&i.NotifiedAt,
		&i.NotifiedBy,
	)
	return i, err
}
